#include "mesh.hpp"

namespace RTV1{
    Mesh::Mesh(std::vector<Vertex> v, std::vector<GLuint> i, std::vector<Texture> tex): vertices(v), indices(i), textures(tex){
        setupMesh();
    }

    void Mesh::draw(Shader &shader){

    }

    void Mesh::setupMesh(){
        glGenVertexArrays(1, &VAO);
        glGenBuffers(1, &VBO);
        glGenBuffers(1, &EBO);
        glBindVertexArray(VAO);
        glBindBuffer(GL_ARRAY_BUFFER, VBO);
        glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(Vertex),
        &vertices[0], GL_STATIC_DRAW);
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
        glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() *
        sizeof(unsigned int), &indices[0], GL_STATIC_DRAW);
        // vertex positions
        glEnableVertexAttribArray(0);
        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex),
        (void*)0);
        // vertex normals
        glEnableVertexAttribArray(1);
        glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex),
        (void*)offsetof(Vertex, Normal));
        // vertex texture coords
        glEnableVertexAttribArray(2);
        glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex),
        (void*)offsetof(Vertex, TexCoords));
        glBindVertexArray(0);
    }

    Mesh& loadMesh(std::string path){
        Assimp::Importer importer;
        std::cout << "Loading mesh file: " << path << std::endl;

        if(!std::filesystem::exists(path)){
            std::cout << "File does not exist" << std::endl;
            return *((Mesh *)NULL);
        }

        const aiScene* scene = importer.ReadFile( path,
            aiProcess_CalcTangentSpace       |
            aiProcess_Triangulate            |
            aiProcess_JoinIdenticalVertices  |
            aiProcess_SortByPType);


        aiMesh * mesh = scene->mMeshes[0];
        std::vector<Vertex> verts;
        for(int vIndex = 0; vIndex < mesh->mNumVertices; vIndex++){
            Vertex vert = 
                {
                    {
                        mesh->mVertices[vIndex].x, 
                        mesh->mVertices[vIndex].y, 
                        mesh->mVertices[vIndex].z
                    },
                    {
                        mesh->mNormals[vIndex].x,
                        mesh->mNormals[vIndex].y,
                        mesh->mNormals[vIndex].z
                    }
                };
            verts.push_back(vert);
        }
        std::cout << verts.size() <<  "Vertecies loaded" << std::endl;
    
    std::vector<GLuint> indices;
    for(unsigned int i = 0; i < mesh->mNumFaces; i++){
            aiFace face = mesh->mFaces[i];
            for(unsigned int j = 0; j < face.mNumIndices; j++)
            indices.push_back(face.mIndices[j]);
        }

        return *new Mesh(verts, indices, {});
    }

}